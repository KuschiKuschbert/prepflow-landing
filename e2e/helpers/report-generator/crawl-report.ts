/**
 * Generate Crawl Console Errors Report - actionable per-page breakdown.
 * Uses non-allowlisted errors only. Groups by page URL for "fix this page" workflow.
 */

import { writeFileSync } from 'fs';
import { join } from 'path';
import type { ErrorRecord } from '../../fixtures/global-error-listener';

function normalizeUrlToPath(url: string): string {
  try {
    const parsed = new URL(url);
    return parsed.pathname || url;
  } catch {
    return url;
  }
}

export function generateCrawlReport(
  errors: ErrorRecord[],
  pagesVisited: Array<{ url: string; depth: number }>,
  outputPath: string = 'CRAWL_REPORT.md',
): void {
  const report: string[] = [];

  report.push('# Crawl Console Errors Report');
  report.push('');
  report.push(`**Generated:** ${new Date().toISOString()}`);
  report.push('');

  const errorsByPage = new Map<string, ErrorRecord[]>();
  for (const err of errors) {
    const path = normalizeUrlToPath(err.url);
    const list = errorsByPage.get(path) || [];
    list.push(err);
    errorsByPage.set(path, list);
  }
  const pagesWithErrors = errorsByPage.size;

  report.push('## Summary');
  report.push('');
  report.push(`- **Pages visited:** ${pagesVisited.length}`);
  report.push(`- **Pages with errors:** ${pagesWithErrors}`);
  report.push(`- **Non-allowlisted errors:** ${errors.length}`);
  report.push('');

  report.push('## Pages Visited');
  report.push('');
  report.push('| URL | Depth |');
  report.push('|-----|-------|');
  for (const { url, depth } of pagesVisited) {
    report.push(`| ${url} | ${depth} |`);
  }
  report.push('');

  if (errors.length > 0) {
    report.push('## Errors by Page');
    report.push('');

    for (const [pagePath, pageErrors] of Array.from(errorsByPage.entries()).sort()) {
      report.push(`### ${pagePath}`);
      report.push('');

      const byType = {
        'console.error': pageErrors.filter(e => e.type === 'console.error'),
        'console.warn': pageErrors.filter(e => e.type === 'console.warn'),
        uncaught: pageErrors.filter(e => e.type === 'uncaught'),
        network: pageErrors.filter(e => e.type === 'network'),
      };

      for (const [type, list] of Object.entries(byType)) {
        if (list.length === 0) continue;
        const count = list.length;
        report.push(`- **${type}** (${count}): \`${list[0].message}\``);
        if (list[0].stack) {
          report.push('  - Stack:');
          report.push('```');
          report.push(list[0].stack);
          report.push('```');
        }
        if (list[0].screenshot) {
          report.push(`  - Screenshot: \`${list[0].screenshot}\``);
        }
        if (count > 1) {
          for (let i = 1; i < list.length; i++) {
            report.push(`  - (${i + 1}) \`${list[i].message}\``);
          }
        }
        report.push('');
      }
    }

    report.push('## Fix Checklist');
    report.push('');
    const sortedPages = Array.from(errorsByPage.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    sortedPages.forEach(([path, list], index) => {
      const count = list.length;
      const types = [...new Set(list.map(e => e.type))].join(', ');
      report.push(`${index + 1}. [ ] ${path} - ${count} error(s) (${types})`);
    });
    report.push('');
  }

  report.push('---');
  report.push('');
  report.push('*Generated by crawl-console-errors.spec.ts*');
  report.push('');
  report.push('**Machine-readable:** For CI/scripts, see `CRAWL_REPORT.json`.');

  const fullPath = join(process.cwd(), outputPath);
  writeFileSync(fullPath, report.join('\n'), 'utf-8');
  console.log(`Crawl report generated: ${fullPath}`);

  const jsonPath = outputPath.replace(/\.md$/i, '.json');
  const jsonReport = {
    generated: new Date().toISOString(),
    markdownReport: outputPath,
    summary: {
      pagesVisited: pagesVisited.length,
      pagesWithErrors: pagesWithErrors,
      totalErrors: errors.length,
    },
    pagesVisited: pagesVisited,
    errorsByPage: Object.fromEntries(
      Array.from(errorsByPage.entries()).sort((a, b) => a[0].localeCompare(b[0])),
    ),
    fixChecklist: Array.from(errorsByPage.entries())
      .sort((a, b) => a[0].localeCompare(b[0]))
      .map(([path, list]) => ({
        path,
        count: list.length,
        types: [...new Set(list.map(e => e.type))],
      })),
  };
  writeFileSync(join(process.cwd(), jsonPath), JSON.stringify(jsonReport, null, 2), 'utf-8');
  console.log(`Crawl report (JSON) generated: ${jsonPath}`);
}

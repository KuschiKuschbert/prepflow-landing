---
alwaysApply: true
---

## üöÄ **Operations & DevOps Standards**

**Note:** For security practices (secrets management, security headers), see `security.mdc`. For CI/CD workflow details, see `development.mdc`. For testing in deployment pipeline, see `testing.mdc`.

### **Environment Management**

**Environment Variables:**

- **Development:** `.env.local` (gitignored)
- **Staging:** Vercel preview deployments (environment variables)
- **Production:** Vercel production environment variables

**Environment Validation:**

- **MANDATORY:** Validate all required environment variables at startup
- **Fail fast:** Application should not start with missing/invalid env vars
- **Documentation:** All env vars documented in `env.example`
- **Secrets:** Never commit secrets to git

**Environment-Specific Behavior:**

- **Development:** Detailed error messages, dev tools enabled
- **Production:** Generic error messages, dev tools disabled
- **Feature flags:** Use environment variables for feature toggles

### **Deployment Process**

**Deployment Pipeline:**

1. **Pre-deployment:**
   - **MANDATORY:** Run `npm run pre-deploy` (runs all checks below automatically)
   - Or run checks individually (same order as CI):
     - Run `npm run lint` (must pass)
     - Run `npm run type-check` (must pass)
     - Run `npm run format:check` (must pass)
     - Run `npm run audit:scripts` (must pass)
     - Run `npm audit --audit-level=moderate` (must pass)
     - Run `npm run build` (must succeed)
     - Run `npm run check:bundle` (must pass)
     - Run `node scripts/check-legal-and-node.js` (verify Node version and legal compliance)
     - Run `bash scripts/verify-vercel-setup.sh` (verify Vercel deployment configuration)

**Pre-deployment Scripts:**
- **Pre-Deploy Check:** `scripts/pre-deploy-check.sh` - **MANDATORY** - Runs the same deploy-critical checks as CI: lint, type-check, format:check, audit:scripts, npm audit, build, check:bundle. Cleanup check runs as advisory only. Use `npm run pre-deploy` to run all checks at once. **See:** `docs/SCRIPTS.md` (Pre-Deployment Check) for details.
- **Legal & Node Check:** `scripts/check-legal-and-node.js` - Verifies Node.js version (>=22.0.0) and legal compliance
- **Vercel Setup Verification:** `scripts/verify-vercel-setup.sh` - Verifies git repository, GitHub Actions workflows, environment variables, and Next.js configuration

**See:** `docs/SCRIPTS.md` for complete script reference.

2. **Deployment:**
   - Push to `main` branch triggers Vercel deployment
   - Vercel runs build and deployment automatically
   - Health check endpoint verified after deployment

3. **Post-deployment:**
   - Verify critical endpoints respond correctly
   - Check error logs for issues
   - Monitor performance metrics
   - Verify analytics tracking

**Deployment Rollback:**

- **Vercel:** Use Vercel dashboard to rollback to previous deployment
- **Process:** Identify issue ‚Üí Rollback ‚Üí Investigate ‚Üí Fix ‚Üí Redeploy
- **Documentation:** Document rollback reason and resolution

**Deployment Checklist:**

- [ ] All tests pass
- [ ] Build succeeds
- [ ] Environment variables configured
- [ ] Database migrations applied (if any)
- [ ] Health check passes
- [ ] Critical endpoints verified
- [ ] Error monitoring active
- [ ] Performance monitoring active

### **Database Management**

**Database Migrations:**

- **MANDATORY:** All schema changes via migrations
- **Version control:** Migrations stored in `migrations/` directory
- **Naming:** `YYYYMMDD_HHMMSS_description.sql`
- **Testing:** Test migrations on staging before production
- **Rollback:** Always provide rollback migration

**Migration Process:**

1. **Create migration:** Write SQL migration file
2. **Test locally:** Apply migration to local database
3. **Test staging:** Apply migration to staging database
4. **Deploy:** Include migration in deployment
5. **Verify:** Confirm migration applied successfully

**Database Backups:**

- **Frequency:** Daily automated backups (Supabase handles)
- **Retention:** 30 days of backups
- **Testing:** Test restore process quarterly
- **Documentation:** Document restore procedure

**Connection Pooling:**

- **MANDATORY:** Use Supabase connection pooling
- **Configuration:** Supabase handles pooling automatically
- **Monitoring:** Monitor connection count and pool usage
- **Limits:** Respect Supabase connection limits

**Database Performance:**

- **Indexes:** Create indexes for frequently queried columns
- **Query optimization:** Use EXPLAIN ANALYZE for slow queries
- **Monitoring:** Monitor query performance and slow queries
- **Optimization:** Optimize N+1 queries using batch endpoints

**Database Setup Scripts:**

- **Database Setup:** `scripts/setup-database.js` - Sets up database tables and schema in Supabase
- **Ingredient Population:** `scripts/populate-ingredients.js` - Populates ingredients table with sample/test data

**Usage:**
```bash
node scripts/setup-database.js
node scripts/populate-ingredients.js
```

**Note:** Requires Supabase credentials in environment variables. See `docs/SCRIPTS.md` for details.

### **Monitoring & Observability**

**Application Monitoring:**

- **Vercel Analytics:** Automatic performance monitoring
- **Error Tracking:** Vercel error tracking (or Sentry)
- **Uptime Monitoring:** External uptime monitoring service
- **Performance Metrics:** Core Web Vitals tracking

**Logging Standards:**

- **Structured Logging:** Use `logger` utility for consistent format
- **Log Levels:** error, warn, info, debug (dev only)
- **Context:** Include user_id, request_id, endpoint in logs
- **Sensitive Data:** Never log passwords, tokens, or PII

**Metrics to Monitor:**

- **Performance:** Response times, Core Web Vitals
- **Errors:** Error rate, error types, stack traces
- **Usage:** Request volume, endpoint usage, user activity
- **Resources:** Database connections, API rate limits

**Alerting:**

- **Critical:** Immediate alerts for downtime or data breaches
- **High:** Alerts for high error rates or performance degradation
- **Medium:** Alerts for unusual patterns or warnings
- **Low:** Daily/weekly summaries for trends

### **Performance Standards**

**Performance Targets:**

- **LCP (Largest Contentful Paint):** < 2.5 seconds
- **FID (First Input Delay):** < 100 milliseconds
- **CLS (Cumulative Layout Shift):** < 0.1
- **TTFB (Time to First Byte):** < 600 milliseconds
- **API Response Time:** < 500 milliseconds (p95)
- **Perceived Mutation Response:** < 50 milliseconds (optimistic updates)

#### **Optimistic Updates Standard**

**MANDATORY:** All CRUD operations (Create, Read, Update, Delete) must use optimistic updates to eliminate loading delays.

**Performance Targets:**

- **Perceived Response Time:** < 50 milliseconds for all mutations
- **No Loading States:** Mutations should never show loading spinners or skeleton screens
- **Error Rollback:** All optimistic updates must have rollback logic for error cases
- **Background Refresh:** Statistics and related data may refresh in background (non-blocking)

**Implementation Requirements:**

1. **Store Original State**: Always store a copy of current state before optimistic updates
2. **Update UI Immediately**: Apply changes to UI before API call completes
3. **Revert on Error**: Restore original state if API call fails
4. **User Feedback**: Use notification system for success/error messages
5. **No Post-Success Fetches**: Never call `fetchData()` after successful mutations - rely on optimistic updates

**Reusable Infrastructure:**

- **`lib/optimistic-updates.ts`**: Generic optimistic update utilities
- **`hooks/useOptimisticMutation.ts`**: Reusable hook for optimistic mutations

**See Also:**
- `development.mdc` (Optimistic Updates Pattern) - Detailed pattern and examples
- `implementation.mdc` (Optimistic Updates Implementation Pattern) - Code examples

**Performance Monitoring:**

- **Real User Monitoring:** Vercel Analytics, Google Analytics
- **Synthetic Monitoring:** Lighthouse CI, performance tests
- **Database Performance:** Supabase query performance monitoring
- **CDN Performance:** Vercel Edge Network performance

**Performance Optimization:**

- **Code Splitting:** Route-based and component-based splitting
- **Image Optimization:** next/image with proper sizing
- **Caching:** Browser caching, CDN caching, API response caching
- **Bundle Size:** Monitor and optimize bundle sizes

## ‚ö° **Speed Optimization & Memoization Standards**

**MANDATORY:** Follow these patterns to optimize application performance and reduce unnecessary re-renders.

### **React Memoization Patterns**

#### **1. React.memo() - Component Memoization**

**When to Use:**
- ‚úÖ Components that receive stable props but re-render frequently
- ‚úÖ List items in large lists (tables, grids, cards)
- ‚úÖ Components that perform expensive rendering operations
- ‚úÖ Components passed as props to memoized parents

**When NOT to Use:**
- ‚ùå Components that receive new object/array props on every render (unless using custom comparison)
- ‚ùå Components that rely on frequently changing context values
- ‚ùå Very simple components (overhead may exceed benefit)

**Usage Pattern:**

```typescript
// ‚úÖ GOOD: Memoize with custom comparison function
import { memo } from 'react';

function MyComponent({ item, onSelect }: MyComponentProps) {
  return <div>{/* component content */}</div>;
}

// Custom comparison for optimal re-render control
export const MemoizedComponent = memo(MyComponent, (prevProps, nextProps) => {
  // Return true if props are equal (prevent re-render)
  // Return false if props changed (allow re-render)
  return (
    prevProps.item.id === nextProps.item.id &&
    prevProps.item.name === nextProps.item.name &&
    prevProps.onSelect === nextProps.onSelect // Callback must be stable (useCallback)
  );
});

// ‚úÖ GOOD: Simple memo (uses shallow comparison)
export const SimpleMemoizedComponent = memo(MyComponent);
```

**Best Practices:**
- Always use custom comparison function for components with object/array props
- Ensure callback props are memoized with `useCallback` in parent
- Only compare props that actually affect rendering

**Real-World Example (from codebase):**

```typescript
// app/webapp/recipes/components/RecipeTableRow.tsx
export const RecipeTableRow = memo(RecipeTableRowComponent, (prevProps, nextProps) => {
  return (
    prevProps.recipe.id === nextProps.recipe.id &&
    prevProps.selectedRecipes === nextProps.selectedRecipes &&
    prevProps.isSelectionMode === nextProps.isSelectionMode &&
    prevProps.isHighlighting === nextProps.isHighlighting &&
    prevProps.recipePrice === nextProps.recipePrice
  );
});
```

#### **2. useMemo() - Value Memoization**

**When to Use:**
- ‚úÖ Expensive computations (filtering, sorting, transforming large arrays)
- ‚úÖ Derived values from props/state
- ‚úÖ Creating new objects/arrays that are used as props
- ‚úÖ Formatting/parsing operations on every render

**When NOT to Use:**
- ‚ùå Simple calculations (overhead may exceed benefit)
- ‚ùå Primitive values (strings, numbers, booleans)
- ‚ùå Values that change on every render anyway

**Usage Pattern:**

```typescript
// ‚úÖ GOOD: Expensive computation
const filteredItems = useMemo(() => {
  return items
    .filter(item => item.active && item.price > 100)
    .sort((a, b) => b.price - a.price)
    .map(item => transformItem(item));
}, [items]); // Only recompute when items change

// ‚úÖ GOOD: Derived value
const totalPrice = useMemo(() => {
  return items.reduce((sum, item) => sum + item.price, 0);
}, [items]);

// ‚úÖ GOOD: Creating stable object/array props
const chartData = useMemo(() => ({
  labels: items.map(item => item.name),
  datasets: [{
    data: items.map(item => item.value),
  }],
}), [items]);

// ‚ùå BAD: Simple calculation (unnecessary memoization)
const doubled = useMemo(() => value * 2, [value]); // Just use: value * 2

// ‚ùå BAD: Creating new value every render anyway
const style = useMemo(() => ({ color: 'red' }), []); // Dependency missing or wrong
```

**Best Practices:**
- Always include all dependencies in dependency array
- Use React DevTools Profiler to verify memoization is helping
- Don't memoize if computation is cheap (< 1ms)

**Real-World Example (from codebase):**

```typescript
// Memoize filtered and sorted navigation items
const filteredItems = useMemo(() => {
  return baseItems.filter(item => {
    if (!searchTerm) return true;
    return item.label.toLowerCase().includes(searchTerm.toLowerCase());
  });
}, [baseItems, searchTerm]);
```

#### **3. useCallback() - Function Memoization**

**When to Use:**
- ‚úÖ Functions passed as props to memoized components
- ‚úÖ Functions used as dependencies in other hooks (useEffect, useMemo)
- ‚úÖ Event handlers in lists (onClick, onChange, etc.)
- ‚úÖ Functions passed to context providers

**When NOT to Use:**
- ‚ùå Functions that are always recreated anyway (e.g., inline functions in JSX)
- ‚ùå Functions that don't affect memoization decisions
- ‚ùå Very simple functions (overhead may exceed benefit)

**Usage Pattern:**

```typescript
// ‚úÖ GOOD: Stable callback for memoized component
const handleSelect = useCallback((id: string) => {
  setSelectedItems(prev => [...prev, id]);
}, []); // Empty deps if function doesn't depend on state/props

// ‚úÖ GOOD: Callback with dependencies
const handleFilter = useCallback((filter: string) => {
  setFilters(prev => ({ ...prev, search: filter }));
  onFilterChange?.(filter);
}, [onFilterChange]);

// ‚úÖ GOOD: Callback used in useEffect dependency
const fetchData = useCallback(async () => {
  const data = await api.getData(userId);
  setData(data);
}, [userId]);

useEffect(() => {
  fetchData();
}, [fetchData]); // Safe to include in deps

// ‚ùå BAD: Unnecessary memoization (function always recreated anyway)
const handleClick = useCallback(() => {
  console.log('clicked');
}, []); // If used inline in JSX, this doesn't help

// ‚ùå BAD: Missing dependencies
const handleSave = useCallback(() => {
  saveItem(item); // item should be in dependency array
}, []); // Missing 'item' dependency
```

**Best Practices:**
- Always include all dependencies in dependency array
- Use empty dependency array only when function truly has no dependencies
- Ensure callbacks are stable when used in memoized component props

**Real-World Example (from codebase):**

```typescript
// Stable callback for memoized table row
const handleSelect = useCallback((id: string) => {
  setSelectedItems(prev =>
    prev.includes(id)
      ? prev.filter(itemId => itemId !== id)
      : [...prev, id]
  );
}, []); // No dependencies - uses functional update
```

### **Memoization Decision Tree**

**Should I memoize this?**

1. **Is it a React component?**
   - ‚úÖ Receives stable props ‚Üí Use `React.memo()`
   - ‚úÖ List item in large list ‚Üí Use `React.memo()` with custom comparison
   - ‚ùå Simple component, no performance issues ‚Üí Skip memoization

2. **Is it an expensive computation?**
   - ‚úÖ Filtering/sorting large arrays (> 100 items) ‚Üí Use `useMemo()`
   - ‚úÖ Complex transformations ‚Üí Use `useMemo()`
   - ‚ùå Simple calculation ‚Üí Skip memoization

3. **Is it a function passed as prop?**
   - ‚úÖ To memoized component ‚Üí Use `useCallback()`
   - ‚úÖ In useEffect dependency ‚Üí Use `useCallback()`
   - ‚ùå Used inline only ‚Üí Skip memoization

### **Performance Optimization Strategies**

#### **1. Code Splitting & Lazy Loading**

**MANDATORY:** Lazy load heavy components and routes.

**Pattern:**

```typescript
// ‚úÖ GOOD: Lazy load heavy components
import dynamic from 'next/dynamic';
import { PageSkeleton } from '@/components/ui/LoadingSkeleton';

const HeavyChart = dynamic(() => import('./HeavyChart'), {
  ssr: false, // Disable SSR for client-only components
  loading: () => <PageSkeleton />, // Show loading state
});

// ‚úÖ GOOD: Lazy load route components
const PerformanceCharts = dynamic(
  () => import('./PerformanceCharts').then(mod => ({ default: mod.PerformanceCharts })),
  {
    ssr: false,
    loading: () => <PageSkeleton />,
  }
);

// ‚úÖ GOOD: Lazy load non-critical components
const BackgroundEffects = dynamic(() => import('./BackgroundEffects'), {
  ssr: false,
  loading: () => null, // No loading state for non-critical components
});
```

**When to Lazy Load:**
- ‚úÖ Chart libraries (Recharts, Chart.js)
- ‚úÖ Heavy UI components (rich text editors, complex forms)
- ‚úÖ Below-the-fold content
- ‚úÖ Modal/dialog components
- ‚úÖ Background effects and animations
- ‚úÖ Admin/advanced features

**When NOT to Lazy Load:**
- ‚ùå Above-the-fold critical content
- ‚ùå Navigation components
- ‚ùå Small, frequently used components
- ‚ùå Components needed for initial render

#### **2. Bundle Optimization**

**Code Splitting Configuration:**

```typescript
// next.config.ts - Already configured, but document patterns
webpack: (config, { dev, isServer }) => {
  if (!dev && !isServer) {
    config.optimization.splitChunks = {
      chunks: 'all',
      minSize: 20000,
      maxSize: 150000,
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
          priority: 10,
        },
        // Separate chunks for heavy libraries
        recharts: {
          test: /[\\/]node_modules[\\/]recharts[\\/]/,
          name: 'recharts',
          chunks: 'async', // Load on demand
          priority: 30,
        },
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
          name: 'react',
          chunks: 'all',
          priority: 25,
        },
      },
    };
  }
  return config;
}
```

**Best Practices:**
- Separate heavy libraries into their own chunks
- Use `chunks: 'async'` for code-split components
- Monitor bundle size with `npm run analyze`
- Keep initial bundle under 200KB (gzipped)

#### **3. Image Optimization**

**MANDATORY:** Use `next/image` for all images.

```typescript
// ‚úÖ GOOD: Optimized image with proper sizing
import Image from 'next/image';

<Image
  src="/images/hero.jpg"
  alt="Hero image"
  width={1200}
  height={800}
  priority // For above-the-fold images
  placeholder="blur" // For better perceived performance
/>

// ‚úÖ GOOD: Responsive images
<Image
  src="/images/feature.jpg"
  alt="Feature"
  width={800}
  height={600}
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
/>
```

**Best Practices:**
- Always specify `width` and `height` (prevents layout shift)
- Use `priority` for above-the-fold images
- Use `placeholder="blur"` for better perceived performance
- Use `sizes` prop for responsive images
- Prefer WebP format (next/image handles conversion)

#### **4. Data Fetching Optimization**

**Caching Strategy:**

```typescript
// ‚úÖ GOOD: Use sessionStorage caching
import { cacheData, getCachedData } from '@/lib/cache/data-cache';

// Initialize with cached data
const [data, setData] = useState(() => getCachedData('my_data') || []);

useEffect(() => {
  // Fetch fresh data in background
  fetch('/api/my-data')
    .then(res => res.json())
    .then(newData => {
      setData(newData);
      cacheData('my_data', newData); // Cache for next visit
    });
}, []);

// ‚úÖ GOOD: Batch fetching for related data
import { fetchInBatches } from '@/lib/api/batch-utils';

const recipeIngredients = await fetchInBatches(
  recipeIds,
  (ids) => fetch(`/api/recipes/ingredients/batch`, {
    method: 'POST',
    body: JSON.stringify({ recipeIds: ids }),
  }),
  100 // Batch size
);

// ‚úÖ GOOD: Parallel fetching for independent data
const [stats, logs] = await Promise.all([
  fetch('/api/dashboard/stats').then(res => res.json()),
  fetch('/api/temperature-logs').then(res => res.json()),
]);
```

**Best Practices:**
- Initialize state with cached data for instant display
- Fetch fresh data in background
- Batch related API calls
- Use parallel fetching for independent requests
- Cache frequently accessed data (5-minute default expiry)

#### **5. Virtual Scrolling (For Large Lists)**

**RECOMMENDED:** Use virtual scrolling for lists > 100 items.

```typescript
// ‚úÖ GOOD: Virtual scrolling for large lists
import { useVirtualizer } from '@tanstack/react-virtual';

function VirtualizedList({ items }: { items: Item[] }) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50, // Estimated row height
  });

  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      <div style={{ height: `${virtualizer.getTotalSize()}px`, position: 'relative' }}>
        {virtualizer.getVirtualItems().map(virtualRow => (
          <div
            key={virtualRow.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualRow.size}px`,
              transform: `translateY(${virtualRow.start}px)`,
            }}
          >
            {items[virtualRow.index].name}
          </div>
        ))}
      </div>
    </div>
  );
}
```

**When to Use:**
- ‚úÖ Lists with > 100 items
- ‚úÖ Tables with many rows
- ‚úÖ Long scrolling feeds

#### **6. Debouncing & Throttling**

**MANDATORY:** Debounce/throttle expensive operations.

```typescript
// ‚úÖ GOOD: Debounce search input
import { useMemo, useState } from 'react';
import { useDebouncedValue } from '@/hooks/useDebouncedValue'; // Custom hook

function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearch = useDebouncedValue(searchTerm, 300); // 300ms delay

  // Only search when debounced value changes
  useEffect(() => {
    if (debouncedSearch) {
      performSearch(debouncedSearch);
    }
  }, [debouncedSearch]);

  return (
    <input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
    />
  );
}

// ‚úÖ GOOD: Throttle scroll events
import { throttle } from 'lodash-es';

const handleScroll = useMemo(
  () => throttle((event: Event) => {
    // Handle scroll (runs max once per 100ms)
    updateScrollPosition(event);
  }, 100),
  []
);
```

**Best Practices:**
- Debounce user input (search, filters) - 300ms typical
- Throttle scroll/resize events - 100ms typical
- Use `useMemo` to create stable debounced/throttled functions

### **Performance Optimization Checklist**

Before deploying, verify:

**React Optimization:**
- [ ] Heavy components use `React.memo()` with custom comparison
- [ ] Expensive computations use `useMemo()`
- [ ] Callbacks passed to memoized components use `useCallback()`
- [ ] Dependency arrays are correct (no missing deps, no unnecessary deps)

**Code Splitting:**
- [ ] Heavy libraries are lazy-loaded
- [ ] Below-the-fold content uses `dynamic()`
- [ ] Route-based code splitting implemented
- [ ] Bundle size monitored (`npm run analyze`)

**Data Fetching:**
- [ ] Caching implemented for frequently accessed data
- [ ] Batch fetching used for related data
- [ ] Parallel fetching used for independent requests
- [ ] Optimistic updates implemented for mutations

**Images:**
- [ ] All images use `next/image`
- [ ] Width and height specified
- [ ] `priority` used for above-the-fold images
- [ ] WebP format preferred

**Runtime Performance:**
- [ ] Virtual scrolling for large lists (> 100 items)
- [ ] Debouncing for user input
- [ ] Throttling for scroll/resize events
- [ ] No unnecessary re-renders (verify with React DevTools Profiler)

### **Performance Monitoring**

**Tools:**
- **React DevTools Profiler:** Identify unnecessary re-renders
- **Lighthouse:** Measure Core Web Vitals
- **Bundle Analyzer:** Monitor bundle size (`npm run analyze`)
- **Vercel Analytics:** Real user monitoring

**Metrics to Track:**
- **LCP (Largest Contentful Paint):** < 2.5s
- **FID (First Input Delay):** < 100ms
- **CLS (Cumulative Layout Shift):** < 0.1
- **Bundle Size:** < 200KB initial (gzipped)
- **API Response Time:** < 500ms (p95)

### **Common Performance Anti-Patterns**

**‚ùå DON'T DO THIS:**

```typescript
// ‚ùå BAD: Creating new object in render (breaks memoization)
<MemoizedComponent style={{ color: 'red' }} /> // New object every render

// ‚ùå BAD: Inline function in memoized component prop
<MemoizedComponent onClick={() => handleClick(id)} /> // New function every render

// ‚ùå BAD: Unnecessary memoization
const value = useMemo(() => someValue, [someValue]); // Just use: someValue

// ‚ùå BAD: Missing dependencies
const handleClick = useCallback(() => {
  doSomething(item); // item not in dependency array
}, []);

// ‚ùå BAD: Fetching on every render
useEffect(() => {
  fetchData(); // Missing dependency array or wrong deps
});
```

**‚úÖ DO THIS INSTEAD:**

```typescript
// ‚úÖ GOOD: Stable style object
const style = useMemo(() => ({ color: 'red' }), []);
<MemoizedComponent style={style} />

// ‚úÖ GOOD: Memoized callback
const handleClick = useCallback(() => handleItemClick(id), [id]);
<MemoizedComponent onClick={handleClick} />

// ‚úÖ GOOD: Only memoize when needed
const expensiveValue = useMemo(() => computeExpensive(data), [data]);

// ‚úÖ GOOD: Correct dependencies
const handleClick = useCallback(() => {
  doSomething(item);
}, [item]); // item in dependency array

// ‚úÖ GOOD: Proper dependency array
useEffect(() => {
  fetchData();
}, [fetchData]); // Or include all deps used in fetchData
```

**See Also:**
- `development.mdc` (Performance Optimization Patterns) - Additional performance patterns
- `development.mdc` (Performance-Aware Refactoring) - Memoization in refactoring context

**Performance Scripts:**

- **Bundle Analysis:** `scripts/analyze-bundle.js` - Analyzes Next.js bundle composition (`npm run analyze`)
- **Performance Budget:** `scripts/check-performance-budget.js` - Checks metrics against defined budgets
- **Performance Regression:** `scripts/check-performance-regression.js` - Detects performance regressions
- **Performance Report:** `scripts/generate-performance-report.js` - Generates comprehensive performance reports
- **Send Performance Report:** `scripts/send-performance-report.js` - Sends reports to configured recipients
- **Performance Optimization:** `scripts/optimize-performance.js` - Automated optimization suggestions
- **Image Optimization:** `scripts/optimize-images.js` - Optimizes images in public directories (converts to WebP, compresses)

**Usage:**
```bash
npm run analyze  # Bundle analysis
node scripts/check-performance-budget.js
node scripts/optimize-images.js
```

**See:** `docs/SCRIPTS.md` for complete performance script reference.

### **Backup & Recovery**

**Backup Strategy:**

- **Database:** Daily automated backups (Supabase)
- **Code:** Git repository (GitHub)
- **Environment Variables:** Vercel environment variables (backed up)
- **User Data:** Database backups include all user data

**Recovery Procedures:**

- **Database Restore:** Document restore process from Supabase backups
- **Code Rollback:** Git revert or Vercel deployment rollback
- **Data Recovery:** Document data recovery procedures
- **Testing:** Test recovery procedures quarterly

**Disaster Recovery:**

- **RTO (Recovery Time Objective):** < 4 hours
- **RPO (Recovery Point Objective):** < 24 hours
- **Documentation:** Document disaster recovery plan
- **Testing:** Annual disaster recovery drill

### **Feature Flags**

**Feature Flag System:**

- **Implementation:** Environment variables for feature toggles
- **Naming:** `FEATURE_FLAG_NAME=true/false`
- **Default:** Features disabled by default
- **Documentation:** Document all feature flags in codebase

**Feature Flag Usage:**

```typescript
// Check feature flag
const isFeatureEnabled = process.env.FEATURE_NEW_DASHBOARD === 'true';

if (isFeatureEnabled) {
  // New feature code
} else {
  // Old feature code
}
```

**Feature Flag Management:**

- **Development:** Enable in `.env.local`
- **Staging:** Enable in Vercel preview environment
- **Production:** Enable in Vercel production environment
- **Rollout:** Gradual rollout using percentage-based flags

### **API Versioning**

**Versioning Strategy:**

- **Current:** No versioning (v1 implicit)
- **Future:** `/api/v1/`, `/api/v2/` when breaking changes needed
- **Deprecation:** 6-month deprecation period for old versions
- **Documentation:** Document API versions and deprecation schedule

**Breaking Changes:**

- **Major version:** Breaking changes require new API version
- **Minor version:** Non-breaking changes in same version
- **Communication:** Notify users of breaking changes 30 days in advance
- **Migration:** Provide migration guides for breaking changes

### **Dependency Management**

**Dependency Updates:**

- **Security:** Fix high/critical vulnerabilities immediately
- **Minor:** Update monthly for bug fixes and patches
- **Major:** Update quarterly with thorough testing
- **Automation:** Use Dependabot for automated PRs

**Dependency Approval:**

- **Review:** Check changelog and breaking changes
- **Test:** Verify dependency doesn't break functionality
- **Security:** Check for known vulnerabilities
- **Approve:** Merge after review and testing

**Dependency Audit:**

- **Weekly:** Run `npm audit` and review results
- **Monthly:** Review all dependencies for updates
- **Quarterly:** Major dependency review and updates
- **Documentation:** Document dependency update decisions

**Dependency Audit Script:**

- **Dependency Audit:** `scripts/audit-dependencies.js` - Audits dependencies for unused packages, heavy dependencies, security vulnerabilities, and update recommendations

**Command:** `npm run audit:deps`

**Output:** Reports unused dependencies, heavy packages, and optimization suggestions.

**See:** `docs/SCRIPTS.md` for complete script reference.

### **Incident Management**

**Incident Response Process:**

1. **Detection:** Identify incident (monitoring, alerts, user reports)
2. **Triage:** Assess severity and impact
3. **Containment:** Stop incident from spreading
4. **Resolution:** Fix root cause
5. **Recovery:** Restore normal operations
6. **Post-mortem:** Document incident and improvements

**Incident Severity:**

- **Critical:** Service down, data breach, security incident
- **High:** Major feature broken, performance degradation
- **Medium:** Minor feature broken, non-critical errors
- **Low:** Cosmetic issues, minor bugs

**Incident Communication:**

- **Status Page:** Update status page during incidents
- **Team:** Notify team via Slack/email
- **Users:** Communicate via status page or in-app notification
- **Post-mortem:** Share post-mortem with team

### **Health Checks**

**Health Check Endpoint:**

- **Route:** `/api/health` (public, no auth required)
- **Response:** `{ status: 'ok', timestamp: '...' }`
- **Checks:** Database connectivity, critical services
- **Monitoring:** External monitoring service pings health endpoint

**Health Check Implementation:**

```typescript
// app/api/health/route.ts
export async function GET() {
  // Check database connectivity
  const dbHealthy = await checkDatabase();

  if (!dbHealthy) {
    return NextResponse.json(
      { status: 'unhealthy', error: 'Database connection failed' },
      { status: 503 }
    );
  }

  return NextResponse.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
  });
}
```

### **Documentation Standards**

**API Documentation:**

- **MANDATORY:** Document all API endpoints
- **Format:** OpenAPI/Swagger specification (future)
- **Examples:** Include request/response examples
- **Authentication:** Document auth requirements

**Code Documentation:**

- **JSDoc:** All public functions, components, hooks
- **README:** Update README with new features
- **CHANGELOG:** Document all changes in CHANGELOG.md
- **Architecture:** Document architectural decisions

**Runbooks:**

- **MANDATORY:** Document common operational tasks
- **Examples:** Database restore, deployment rollback, incident response
- **Updates:** Keep runbooks updated with process changes
- **Access:** Runbooks accessible to all team members

## ü§ñ **Automated Enforcement**

**Cleanup System:** See `cleanup.mdc` for comprehensive automated enforcement of all operations standards.

**Available Checks:**
- Performance: `npm run cleanup:check` (validates bundle size, API response times)
- Performance monitoring: Manual review (Core Web Vitals)

**Available Fixes:**
- Performance: Manual optimization required

**Standards Reference:** See `cleanup.mdc` (Performance Standards) for complete enforcement details.

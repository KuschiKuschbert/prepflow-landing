---
alwaysApply: true
---

## üîí **Security Standards & Best Practices**

**Note:** For authentication setup and allowlist configuration, see `core.mdc`. For deployment security and monitoring, see `operations.mdc`. For security testing standards, see `testing.mdc`.

**üìö Auth0 & Stripe Security:** See `docs/AUTH0_STRIPE_REFERENCE.md` for comprehensive Auth0 and Stripe security practices, webhook signature verification, and secrets management.

### **Environment Variable Validation**

**MANDATORY:** All environment variables must be validated at application startup.

**Implementation Pattern:**

```typescript
// lib/env-validation.ts
import { z } from 'zod'; // Add zod as dependency

const envSchema = z.object({
  // Supabase
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),

  // Auth0 (see docs/AUTH0_STRIPE_REFERENCE.md for complete list)
  NEXTAUTH_SECRET: z.string().min(32),
  NEXTAUTH_URL: z.string().url(),
  AUTH0_ISSUER_BASE_URL: z.string().url().optional(),
  AUTH0_CLIENT_ID: z.string().optional(),
  AUTH0_CLIENT_SECRET: z.string().optional(),

  // Stripe (see docs/AUTH0_STRIPE_REFERENCE.md for complete list)
  STRIPE_SECRET_KEY: z.string().startsWith('sk_').optional(),
  STRIPE_WEBHOOK_SECRET: z.string().startsWith('whsec_').optional(),
  STRIPE_PRICE_STARTER_MONTHLY: z.string().startsWith('price_').optional(),
  STRIPE_PRICE_PRO_MONTHLY: z.string().startsWith('price_').optional(),
  STRIPE_PRICE_BUSINESS_MONTHLY: z.string().startsWith('price_').optional(),

  // Node Environment
  NODE_ENV: z.enum(['development', 'production', 'test']),
});

export const env = envSchema.parse(process.env);
```

**Usage:**

- Validate on app startup in `app/layout.tsx` or `middleware.ts`
- Fail fast with clear error messages if validation fails
- Never use `process.env` directly - always use validated `env` object

### **Secrets Management**

**MANDATORY:** Follow these security practices for secrets:

- **Never commit secrets** to git (use `.env.local`, `.gitignore`)
- **Rotate secrets regularly** (every 90 days for production)
- **Use different secrets** for development, staging, and production
- **Store production secrets** in Vercel environment variables (never in code)
- **Use strong secrets** (minimum 32 characters, random generation)
- **Never log secrets** (use `logger` utility which redacts sensitive data)

**Secret Generation:**

```bash
# Generate secure random secrets
openssl rand -hex 32  # For NEXTAUTH_SECRET
openssl rand -base64 32  # For AUTH0_SECRET
```

**Secret Rotation Process:**

1. Generate new secret
2. Update in Vercel environment variables
3. Deploy new version
4. Verify functionality
5. Mark old secret for deletion (after 7 days grace period)

### **API Security**

**Rate Limiting:**

- **MANDATORY:** Implement rate limiting on all public API endpoints
- **Default Limits:** 100 requests per 15 minutes per IP
- **Stricter Limits:** 10 requests per minute for authentication endpoints
- **Implementation:** Use middleware or API route wrapper

**Input Validation:**

- **MANDATORY:** Validate all input data using Zod schemas
- **Sanitize user input** before database operations
- **Reject malformed requests** with 400 status codes
- **Never trust client-side validation** - always validate server-side

**SQL Injection Prevention:**

- **MANDATORY:** Use Supabase parameterized queries only
- **Never concatenate** user input into SQL strings
- **Use Supabase client methods** (`.insert()`, `.update()`, `.select()`)
- **Validate data types** before database operations

**XSS Prevention:**

- **MANDATORY:** Sanitize all user-generated content
- **Use React's built-in escaping** (automatic for JSX)
- **Never use `dangerouslySetInnerHTML`** without sanitization
- **Content Security Policy** configured in `next.config.ts`

**CSRF Protection:**

- **MANDATORY:** Use NextAuth CSRF tokens for authenticated requests
- **Verify origin headers** for API requests
- **Use SameSite cookies** for session management

**See Also:**
- `security.mdc` (Database Query Security Patterns) - Secure database query patterns
- `security.mdc` (Input Sanitization & Validation Standards) - Input validation requirements

### **Database Query Security Patterns**

**MANDATORY:** All database queries must follow these security patterns to prevent SQL injection and ensure data integrity.

#### **Supabase Query Safety**

**Safe Patterns (‚úÖ Use These):**

```typescript
// ‚úÖ SAFE: Use Supabase query builder methods
const { data, error } = await supabase
  .from('recipes')
  .select('*')
  .eq('id', recipeId) // Parameterized automatically
  .like('name', `%${searchTerm}%`) // Handles escaping

// ‚úÖ SAFE: Use .in() with array
const { data, error } = await supabase
  .from('ingredients')
  .select('*')
  .in('id', ingredientIds) // Array is safely parameterized

// ‚úÖ SAFE: Use .ilike() with proper escaping
const { data, error } = await supabase
  .from('recipes')
  .select('*')
  .ilike('name', `%${searchTerm}%`) // Supabase handles escaping

// ‚úÖ SAFE: Filter objects
const { data, error } = await supabase
  .from('recipes')
  .select('*')
  .filter('name', 'ilike', `%${searchTerm}%`) // Explicit filter method
```

**Unsafe Patterns (‚ùå NEVER Use These):**

```typescript
// ‚ùå UNSAFE: String interpolation in .or() clause
query.or(`name.ilike.%${userInput}%,email.ilike.%${userInput}%`)
// Problem: While Supabase escapes values, string interpolation is error-prone

// ‚ùå UNSAFE: Raw SQL with user input
await supabase.rpc('custom_function', { query: userInput })
// Problem: If function uses string concatenation, vulnerable to SQL injection

// ‚ùå UNSAFE: Direct value insertion without validation
await supabase.from('table').insert({ name: userInput })
// Problem: Should validate and sanitize userInput first
```

**Recommended Safe Pattern for Complex Queries:**

```typescript
// ‚úÖ SAFE: Build queries incrementally with validation
function buildSafeSearchQuery(searchTerm: string) {
  // Validate and sanitize input first
  const sanitized = searchTerm.trim().slice(0, 200); // Limit length

  // Use filter() method for complex queries (safer than string interpolation)
  let query = supabase.from('recipes').select('*');

  query = query.or(`name.ilike.%${sanitized}%,description.ilike.%${sanitized}%`);
  // Note: Supabase escapes values in .or() clauses, but sanitize first anyway

  return query;
}

// Better: Use separate .or() calls or .filter() with explicit escaping
function buildSaferSearchQuery(searchTerm: string) {
  const sanitized = escapeSearchTerm(searchTerm); // Custom sanitization

  return supabase
    .from('recipes')
    .select('*')
    .or(`name.ilike.%${sanitized}%,description.ilike.%${sanitized}%`);
}
```

#### **Input Sanitization for Search Queries**

```typescript
// lib/utils/sanitize.ts
/**
 * Sanitize search input to prevent injection attacks
 */
export function sanitizeSearchInput(input: string): string {
  return input
    .trim()
    .slice(0, 200) // Limit length
    .replace(/[%_]/g, '') // Remove SQL wildcards (optional - Supabase handles this)
    .replace(/[<>]/g, ''); // Remove potential HTML (defense in depth)
}

/**
 * Escape special characters for Supabase .ilike() queries
 */
export function escapeSearchTerm(term: string): string {
  // Supabase handles escaping, but we sanitize anyway for safety
  return term
    .trim()
    .slice(0, 200)
    .replace(/[\\%_]/g, (char) => `\\${char}`); // Escape backslash, %, _
}
```

#### **Query Parameter Validation**

**MANDATORY:** Validate all query parameters before use:

```typescript
// ‚úÖ SAFE: Validate before query
const schema = z.object({
  page: z.number().int().positive().default(1),
  pageSize: z.number().int().positive().max(100).default(20),
  search: z.string().max(200).optional(),
});

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const params = schema.parse({
    page: Number(searchParams.get('page')) || 1,
    pageSize: Number(searchParams.get('pageSize')) || 20,
    search: searchParams.get('search') || undefined,
  });

  // Now params are validated and safe to use
  const query = supabase.from('recipes').select('*');

  if (params.search) {
    const sanitized = sanitizeSearchInput(params.search);
    query.ilike('name', `%${sanitized}%`);
  }

  // ... rest of query
}
```

#### **Query Timeout Protection**

**RECOMMENDED:** Add timeout protection for all database queries:

```typescript
// lib/utils/query-timeout.ts
export async function withQueryTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number = 10000
): Promise<T> {
  const timeout = new Promise<never>((_, reject) =>
    setTimeout(() => reject(new Error('Query timeout')), timeoutMs)
  );

  return Promise.race([promise, timeout]);
}

// Usage:
const { data, error } = await withQueryTimeout(
  supabase.from('recipes').select('*'),
  5000 // 5 second timeout
);
```

#### **Query Result Validation**

**RECOMMENDED:** Validate query results match expected schema:

```typescript
// Define result schema
const RecipeSchema = z.object({
  id: z.number(),
  name: z.string(),
  description: z.string().optional(),
  // ... other fields
});

// Validate results
const { data, error } = await supabase.from('recipes').select('*');

if (error) {
  throw new Error(`Query failed: ${error.message}`);
}

// Validate all results match schema
const validatedData = data?.map(recipe => RecipeSchema.parse(recipe)) || [];
```

#### **Connection Pooling Best Practices**

**MANDATORY:** Follow these patterns for database connections:

```typescript
// ‚úÖ CORRECT: Use singleton Supabase client
import { supabaseAdmin } from '@/lib/supabase';

// ‚úÖ CORRECT: Use connection pooling (Supabase handles automatically)
// No need to manage connections manually

// ‚ùå INCORRECT: Creating new clients for each request
const supabase = createClient(...); // Don't do this in route handlers
```

#### **Query Security Checklist**

For every database query, verify:
- [ ] User input is validated before use
- [ ] User input is sanitized (search terms, filters)
- [ ] Supabase query builder methods are used (no raw SQL)
- [ ] Query parameters are type-checked
- [ ] Query results are validated against schema
- [ ] Query timeouts are implemented (for long-running queries)
- [ ] Error handling doesn't expose sensitive information
- [ ] Queries use indexes (where applicable)
- [ ] Queries are paginated (for large datasets)

**See Also:**
- `security.mdc` (Input Sanitization & Validation Standards) - Comprehensive input validation patterns
- `core.mdc` (Supabase TypeScript Gotcha) - Query builder patterns

### **Input Sanitization & Validation Standards**

**MANDATORY:** All user input must be validated and sanitized before use.

#### **Input Sanitization Library**

**RECOMMENDED:** Use DOMPurify for HTML sanitization when needed:

```typescript
// lib/utils/sanitize.ts
import DOMPurify from 'isomorphic-dompurify';

/**
 * Sanitize HTML content to prevent XSS attacks
 */
export function sanitizeHTML(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
    ALLOWED_ATTR: [],
  });
}

/**
 * Sanitize text input (removes HTML tags)
 */
export function sanitizeText(input: string): string {
  return DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
}

/**
 * Sanitize search input
 */
export function sanitizeSearchInput(input: string): string {
  return input
    .trim()
    .slice(0, 200) // Limit length
    .replace(/[<>]/g, '') // Remove HTML brackets
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+=/gi, ''); // Remove event handlers
}
```

#### **React XSS Prevention**

**MANDATORY:** Follow these patterns in React components:

```typescript
// ‚úÖ SAFE: React automatically escapes JSX
<div>{userInput}</div> // Automatically escaped

// ‚úÖ SAFE: Using dangerouslySetInnerHTML with sanitization
<div dangerouslySetInnerHTML={{ __html: sanitizeHTML(userContent) }} />

// ‚ùå UNSAFE: Using dangerouslySetInnerHTML without sanitization
<div dangerouslySetInnerHTML={{ __html: userContent }} />

// ‚ùå UNSAFE: Direct HTML string manipulation
element.innerHTML = userContent;

// ‚ùå UNSAFE: eval() with user input
eval(userInput);
```

#### **URL Validation**

**MANDATORY:** Validate URLs before use:

```typescript
// lib/utils/validate-url.ts
import { z } from 'zod';

const urlSchema = z.string().url().refine(
  (url) => {
    try {
      const parsed = new URL(url);
      // Only allow http/https protocols
      return ['http:', 'https:'].includes(parsed.protocol);
    } catch {
      return false;
    }
  },
  { message: 'Invalid URL protocol' }
);

export function validateURL(url: string): boolean {
  return urlSchema.safeParse(url).success;
}

// Usage:
if (!validateURL(userProvidedURL)) {
  throw new Error('Invalid URL');
}
```

#### **File Upload Security**

**MANDATORY:** Secure file upload handling:

```typescript
// lib/utils/validate-file.ts
import { z } from 'zod';

const ALLOWED_FILE_TYPES = ['image/jpeg', 'image/png', 'image/webp'];
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

export function validateFile(file: File): { valid: boolean; error?: string } {
  // Check file type
  if (!ALLOWED_FILE_TYPES.includes(file.type)) {
    return { valid: false, error: 'Invalid file type' };
  }

  // Check file size
  if (file.size > MAX_FILE_SIZE) {
    return { valid: false, error: 'File too large' };
  }

  // Check file name
  if (!/^[a-zA-Z0-9._-]+$/.test(file.name)) {
    return { valid: false, error: 'Invalid file name' };
  }

  return { valid: true };
}
```

#### **JSON Input Validation**

**MANDATORY:** Validate JSON input with Zod:

```typescript
// Always validate JSON input
const body = await request.json();
const validatedData = schema.parse(body); // Throws if invalid

// Never trust JSON structure without validation
// ‚ùå BAD:
const data = await request.json();
const name = data.name; // No validation!

// ‚úÖ GOOD:
const schema = z.object({ name: z.string().min(1) });
const { name } = schema.parse(await request.json());
```

#### **Input Sanitization Checklist**

For every user input, verify:
- [ ] Input is validated with Zod schema
- [ ] Input is sanitized (if needed for display)
- [ ] Input length is limited
- [ ] Input type is checked (string, number, etc.)
- [ ] Special characters are handled safely
- [ ] HTML content is sanitized (if displayed)
- [ ] URLs are validated (if used in links/redirects)
- [ ] File uploads are validated (type, size, name)

**See Also:**
- `security.mdc` (Database Query Security Patterns) - Query parameter validation
- `security.mdc` (API Security) - API input validation requirements

### **Authentication & Authorization**

**üìö Auth0 Implementation:** See `docs/AUTH0_STRIPE_REFERENCE.md` (Auth0 Configuration section) for complete Auth0 setup, session management, and role extraction.

**Session Management:**

- **Secure cookies** with `httpOnly`, `secure`, `sameSite: 'strict'`
- **Session timeout:** 4 hours (configurable via `NEXTAUTH_SESSION_MAX_AGE`)
- **Token refresh:** Automatic via NextAuth
- **Logout:** Clear all session data server-side
- **JWT Strategy:** Stateless authentication (no database lookups for session validation)

**Authorization Checks:**

- **MANDATORY:** Verify permissions on every API route
- **Check user_id** matches resource ownership (when user isolation implemented)
- **Validate subscription status** for premium features (see `lib/feature-gate.ts`)
- **Fail closed:** Deny access by default, allow explicitly
- **Role Extraction:** Multiple fallback sources (token ‚Üí Management API)

**Password Security (if implementing custom auth):**

- **Minimum length:** 12 characters
- **Complexity requirements:** Mix of uppercase, lowercase, numbers, symbols
- **Hashing:** Use bcrypt with 12+ rounds
- **Never store plaintext passwords**

### **Data Privacy & GDPR Compliance**

**Data Collection:**

- **MANDATORY:** Only collect data necessary for functionality
- **User consent** required for analytics and tracking
- **Privacy policy** must be accessible and clear
- **Data retention** policies documented and enforced

**User Data Rights:**

- **Right to access:** `/api/account/export` endpoint implemented
- **Right to deletion:** `/api/account/delete` endpoint implemented
- **Right to rectification:** Users can update their data
- **Data portability:** Export in JSON format

**Data Storage:**

- **Encryption at rest:** Supabase handles database encryption
- **Encryption in transit:** HTTPS/TLS for all connections
- **Backup encryption:** Ensure backups are encrypted
- **PII handling:** Minimize personally identifiable information storage

### **Security Headers**

**MANDATORY:** All responses must include security headers (configured in `next.config.ts`):

- **X-Frame-Options:** DENY (prevent clickjacking)
- **X-Content-Type-Options:** nosniff (prevent MIME sniffing)
- **Strict-Transport-Security:** max-age=31536000 (force HTTPS)
- **Content-Security-Policy:** Restrict resource loading
- **Referrer-Policy:** origin-when-cross-origin
- **Permissions-Policy:** Restrict browser features

### **Security Monitoring**

**Logging:**

- **MANDATORY:** Log all security events (failed logins, unauthorized access attempts)
- **Never log sensitive data** (passwords, tokens, PII)
- **Use structured logging** with context (user_id, IP, endpoint)
- **Monitor logs** for suspicious patterns

**Alerting:**

- **Failed authentication attempts:** Alert after 5 failures from same IP
- **Unauthorized access attempts:** Alert immediately
- **Unusual API usage:** Alert on rate limit violations
- **Database errors:** Alert on connection failures or query errors

**Security Audits:**

- **Dependency scanning:** Run `npm audit` weekly
- **Code scanning:** Use GitHub Security or similar
- **Penetration testing:** Annual external security audit
- **Vulnerability disclosure:** Process for reporting security issues

### **Incident Response**

**Security Incident Process:**

1. **Detect:** Identify security incident (breach, vulnerability, attack)
2. **Contain:** Isolate affected systems immediately
3. **Assess:** Determine scope and impact
4. **Remediate:** Fix vulnerability or stop attack
5. **Document:** Record incident details and response
6. **Notify:** Inform affected users if data breach occurred
7. **Review:** Post-incident review and process improvement

**Incident Contacts:**

- **Security Lead:** [Define contact]
- **DevOps Lead:** [Define contact]
- **Legal/Compliance:** [Define contact]

### **Dependency Security**

**MANDATORY:** Regular dependency updates and security scanning:

- **Weekly:** Run `npm audit` and fix high/critical vulnerabilities
- **Monthly:** Review and update dependencies
- **Quarterly:** Major dependency updates and testing
- **Automated:** Use Dependabot or similar for automated PRs

**Dependency Approval Process:**

1. **Review:** Check vulnerability database (npm audit, Snyk)
2. **Test:** Verify dependency doesn't break functionality
3. **Approve:** Merge dependency update PR
4. **Monitor:** Watch for issues after deployment

### **API Security Checklist**

For every new API endpoint:

- [ ] Input validation with Zod schema
- [ ] Authentication check (if protected route)
- [ ] Authorization check (if user-specific data)
- [ ] Rate limiting applied
- [ ] Error handling (no sensitive data in errors)
- [ ] Logging (security events logged)
- [ ] SQL injection prevention (parameterized queries)
- [ ] XSS prevention (sanitized output)
- [ ] CSRF protection (NextAuth tokens)

**For Stripe Webhook Endpoints:**
- [ ] Webhook signature verification (MANDATORY - see `docs/AUTH0_STRIPE_REFERENCE.md`)
- [ ] Idempotency checking (via `webhook_events` table)
- [ ] Environment-specific secrets (DEV/PROD)
- [ ] Proper HTTP status codes for retries (200 = success, 400 = don't retry, 500 = retry)

### **Security Testing**

**MANDATORY:** Security testing before production deployment:

- **Dependency scanning:** `npm audit`
- **Code scanning:** ESLint security rules
- **Manual testing:** Authentication, authorization, input validation
- **Penetration testing:** Annual external audit

**Security Test Checklist:**

- [ ] All endpoints require authentication (where applicable)
- [ ] Authorization checks prevent unauthorized access
- [ ] Input validation prevents malformed data
- [ ] Rate limiting prevents abuse
- [ ] Error messages don't leak sensitive information
- [ ] Security headers are present
- [ ] No secrets in logs or error messages
- [ ] SQL injection prevention verified
- [ ] XSS prevention verified

### **Security Hardening Patterns**

**MANDATORY:** Apply these security hardening patterns throughout the codebase.

#### **Content Security Policy (CSP) Hardening**

**RECOMMENDED:** Implement strict CSP with nonce-based inline scripts:

```typescript
// middleware.ts or next.config.ts
const nonce = Buffer.from(crypto.randomBytes(16)).toString('base64');

// In headers:
{
  key: 'Content-Security-Policy',
  value: `
    default-src 'self';
    script-src 'self' 'nonce-${nonce}' https://www.googletagmanager.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    img-src 'self' data: https:;
    connect-src 'self' https://*.supabase.co;
    font-src 'self' https://fonts.gstatic.com;
  `.replace(/\s+/g, ' ').trim()
}
```

#### **HTTP Security Headers**

**MANDATORY:** Include all security headers (see Security Headers section for full list):

- X-Frame-Options: DENY
- X-Content-Type-Options: nosniff
- X-XSS-Protection: 1; mode=block
- Strict-Transport-Security: max-age=31536000
- Content-Security-Policy: (configured per application)
- Referrer-Policy: origin-when-cross-origin
- Permissions-Policy: (restrictive)
- Cross-Origin-Embedder-Policy: require-corp
- Cross-Origin-Opener-Policy: same-origin
- Cross-Origin-Resource-Policy: same-origin

#### **Rate Limiting Hardening**

**RECOMMENDED:** Implement progressive rate limiting:

```typescript
// lib/rate-limit.ts (enhanced)
interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  blockDuration?: number; // Block IP after exceeding limit
}

// Progressive rate limiting
const RATE_LIMITS: Record<string, RateLimitConfig> = {
  '/api/auth/login': {
    windowMs: 15 * 60 * 1000,
    maxRequests: 5,
    blockDuration: 30 * 60 * 1000, // Block for 30 minutes
  },
  '/api/auth/register': {
    windowMs: 60 * 60 * 1000,
    maxRequests: 3,
    blockDuration: 60 * 60 * 1000, // Block for 1 hour
  },
};
```

#### **Session Security Hardening**

**MANDATORY:** Implement secure session management:

```typescript
// Session configuration
const sessionConfig = {
  httpOnly: true, // Prevent XSS access
  secure: process.env.NODE_ENV === 'production', // HTTPS only
  sameSite: 'strict' as const, // CSRF protection
  maxAge: 4 * 60 * 60, // 4 hours
  path: '/',
};
```

#### **API Key Security**

**MANDATORY:** Secure API key handling:

```typescript
// ‚úÖ GOOD: Environment variables
const apiKey = process.env.SECRET_API_KEY;

// ‚úÖ GOOD: Validate API key format
function validateApiKey(key: string): boolean {
  return /^[a-zA-Z0-9]{32,}$/.test(key);
}

// ‚ùå BAD: Hardcoded keys
const apiKey = 'hardcoded-key-123';

// ‚ùå BAD: Exposed in client code
const apiKey = process.env.NEXT_PUBLIC_API_KEY; // Don't use NEXT_PUBLIC_ for secrets
```

#### **Logging Security**

**MANDATORY:** Never log sensitive information:

```typescript
// ‚úÖ GOOD: Sanitized logging
logger.info('User action', {
  userId: user.id,
  action: 'login',
  // Never log: passwords, tokens, PII
});

// ‚ùå BAD: Logging sensitive data
logger.info('User login', {
  email: user.email,
  password: user.password, // NEVER!
  token: user.token, // NEVER!
});
```

#### **Dependency Security**

**MANDATORY:** Regular security audits:

```bash
# Weekly: Check for vulnerabilities
npm audit

# Monthly: Update dependencies
npm update

# Quarterly: Major updates with testing
npm audit fix --force
```

#### **Secrets Rotation**

**MANDATORY:** Regular secret rotation schedule:

- **Production secrets:** Rotate every 90 days
- **Development secrets:** Rotate every 180 days
- **Compromised secrets:** Rotate immediately
- **Service account keys:** Rotate every 60 days

#### **Security Hardening Checklist**

For every security-sensitive operation, verify:
- [ ] Input is validated and sanitized
- [ ] Output is sanitized (if user-generated)
- [ ] Authentication is verified
- [ ] Authorization is checked
- [ ] Rate limiting is applied
- [ ] Secrets are not logged
- [ ] Errors don't leak sensitive information
- [ ] Security headers are present
- [ ] HTTPS is enforced (production)
- [ ] Session security is configured
- [ ] Dependencies are up-to-date
- [ ] Security audits are run regularly

**See Also:**
- `security.mdc` (Security Headers) - Complete security headers configuration
- `security.mdc` (API Security) - API security requirements
- `operations.mdc` (Dependency Management) - Dependency update procedures

## ü§ñ **Automated Enforcement**

**Cleanup System:** See `cleanup.mdc` for comprehensive automated enforcement of all security standards.

**Available Checks:**
- Security patterns: `npm run cleanup:check` (validates input validation, rate limiting patterns)
- API security: Manual review (security headers, CSRF protection)

**Available Fixes:**
- Security patterns: Manual fixes required

**Standards Reference:** See `cleanup.mdc` (Security Standards) for complete enforcement details.

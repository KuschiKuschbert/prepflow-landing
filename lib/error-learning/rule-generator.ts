/**
 * Rule Generation System
 * Generates rules from fix patterns to prevent similar errors
 */

import fs from 'fs/promises';
import path from 'path';
import {
  loadKnowledgeBase,
  addPatternToKnowledgeBase,
  addRuleToKnowledgeBase,
} from './knowledge-base';
import type { KnowledgeBasePattern, KnowledgeBaseRule } from './knowledge-base';

const ERROR_PATTERNS_FILE = path.join(process.cwd(), '.cursor/rules/error-patterns.mdc');
const MIN_FIX_COUNT_FOR_RULE = 3; // Minimum number of fixes before generating rule

/**
 * Extract pattern from fixes
 */
function extractPattern(fixes: Array<{ solution: string; prevention: string }>): {
  name: string;
  description: string;
  detection: string;
  fix: string;
  prevention: string;
} | null {
  if (fixes.length < MIN_FIX_COUNT_FOR_RULE) {
    return null; // Not enough fixes to generate pattern
  }

  // Extract common solution pattern
  const solutions = fixes.map(f => f.solution);
  const commonSolution = findCommonPattern(solutions);

  // Extract common prevention pattern
  const preventions = fixes.map(f => f.prevention);
  const commonPrevention = findCommonPattern(preventions);

  if (!commonSolution && !commonPrevention) {
    return null; // No clear pattern
  }

  // Generate pattern name from solution
  const patternName = commonSolution
    ? commonSolution.substring(0, 60).replace(/[^a-zA-Z0-9\s]/g, '')
    : 'Unknown Pattern';

  return {
    name: patternName,
    description: `Pattern learned from ${fixes.length} fixes`,
    detection: 'Error pattern detected from knowledge base',
    fix: commonSolution || 'Review fixes in knowledge base',
    prevention: commonPrevention || 'Follow prevention strategies from fixes',
  };
}

/**
 * Find common pattern in array of strings
 */
function findCommonPattern(strings: string[]): string | null {
  if (strings.length === 0) {
    return null;
  }

  // Simple approach: find common words/phrases
  const allWords = strings
    .join(' ')
    .toLowerCase()
    .split(/\s+/)
    .filter(word => word.length > 3);

  const wordCounts: Record<string, number> = {};
  for (const word of allWords) {
    wordCounts[word] = (wordCounts[word] || 0) + 1;
  }

  // Find words that appear in at least 50% of strings
  const threshold = strings.length * 0.5;
  const commonWords = Object.entries(wordCounts)
    .filter(([_, count]) => count >= threshold)
    .map(([word]) => word);

  if (commonWords.length === 0) {
    return null;
  }

  // Return first common phrase (can be enhanced)
  return commonWords[0];
}

/**
 * Generate rule from pattern
 */
function generateRule(pattern: KnowledgeBasePattern): KnowledgeBaseRule {
  return {
    id: `rule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    name: pattern.name,
    source: 'error-patterns.mdc',
    enforcement: 'automated',
  };
}

/**
 * Update error-patterns.mdc with new pattern
 */
async function updateErrorPatternsFile(
  pattern: KnowledgeBasePattern,
  _rule: KnowledgeBaseRule,
): Promise<void> {
  const patternsDir = path.dirname(ERROR_PATTERNS_FILE);
  await fs.mkdir(patternsDir, { recursive: true });

  // Check if file exists
  let content = '';
  try {
    content = await fs.readFile(ERROR_PATTERNS_FILE, 'utf8');
  } catch {
    // File doesn't exist, create default content
    content = `---
alwaysApply: true
---

# Error Patterns & Learned Fixes

This file is automatically generated and updated based on errors encountered and fixes documented in the knowledge base.

## Overview

This file contains error patterns learned from actual errors in the codebase, along with their fixes and prevention strategies.

## ${pattern.name}

### Pattern Description

${pattern.description}

### Detection

${pattern.detection}

### Fix

${pattern.fix}

### Prevention

${pattern.prevention}

`;
  }

  // Add new pattern before the last section (before "## Updating This File")
  const updateSection = `## ${pattern.name}

### Pattern Description

${pattern.description}

### Detection

${pattern.detection}

### Fix

${pattern.fix}

### Prevention

${pattern.prevention}

`;

  // Insert before "## Updating This File" section
  const updateMarker = '## Updating This File';
  if (content.includes(updateMarker)) {
    content = content.replace(updateMarker, updateSection + updateMarker);
  } else {
    // Append to end
    content += '\n' + updateSection;
  }

  await fs.writeFile(ERROR_PATTERNS_FILE, content, 'utf8');
}

/**
 * Generate rules from knowledge base
 */
export async function generateRulesFromKnowledgeBase(): Promise<{
  patterns: KnowledgeBasePattern[];
  rules: KnowledgeBaseRule[];
}> {
  const kb = await loadKnowledgeBase();
  const newPatterns: KnowledgeBasePattern[] = [];
  const newRules: KnowledgeBaseRule[] = [];

  // Group errors by pattern
  const errorGroups: Record<string, typeof kb.errors> = {};

  for (const error of kb.errors) {
    const patternKey = `${error.errorType}-${error.category}`;
    if (!errorGroups[patternKey]) {
      errorGroups[patternKey] = [];
    }
    errorGroups[patternKey].push(error);
  }

  // Generate patterns from error groups with multiple fixes
  for (const [patternKey, errors] of Object.entries(errorGroups)) {
    // Collect all fixes for this pattern
    const allFixes = errors.flatMap(err =>
      err.fixes.map(fix => ({
        solution: fix.solution,
        prevention: fix.prevention,
      })),
    );

    if (allFixes.length >= MIN_FIX_COUNT_FOR_RULE) {
      // Check if pattern already exists
      const existingPattern = kb.patterns.find(p => p.id === patternKey);

      if (!existingPattern) {
        // Extract pattern
        const patternData = extractPattern(allFixes);

        if (patternData) {
          const pattern: KnowledgeBasePattern = {
            id: patternKey,
            ...patternData,
          };

          // Add to knowledge base
          await addPatternToKnowledgeBase(pattern);
          newPatterns.push(pattern);

          // Generate rule
          const rule = generateRule(pattern);
          await addRuleToKnowledgeBase(rule);
          newRules.push(rule);

          // Update error-patterns.mdc
          await updateErrorPatternsFile(pattern, rule);
        }
      }
    }
  }

  return { patterns: newPatterns, rules: newRules };
}

/**
 * Generate rules from recent fixes
 */
export async function generateRulesFromRecentFixes(days = 7): Promise<{
  patterns: KnowledgeBasePattern[];
  rules: KnowledgeBaseRule[];
}> {
  const kb = await loadKnowledgeBase();
  const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

  // Get recent fixes
  const recentFixes = kb.errors.flatMap(err =>
    err.fixes
      .filter(fix => new Date(fix.documentedAt) >= cutoffDate)
      .map(fix => ({
        errorType: err.errorType,
        category: err.category,
        solution: fix.solution,
        prevention: fix.prevention,
      })),
  );

  // Group by error type and category
  const fixGroups: Record<string, typeof recentFixes> = {};

  for (const fix of recentFixes) {
    const key = `${fix.errorType}-${fix.category}`;
    if (!fixGroups[key]) {
      fixGroups[key] = [];
    }
    fixGroups[key].push(fix);
  }

  const newPatterns: KnowledgeBasePattern[] = [];
  const newRules: KnowledgeBaseRule[] = [];

  // Generate patterns for groups with enough fixes
  for (const [key, fixes] of Object.entries(fixGroups)) {
    if (fixes.length >= MIN_FIX_COUNT_FOR_RULE) {
      const patternData = extractPattern(
        fixes.map(f => ({ solution: f.solution, prevention: f.prevention })),
      );

      if (patternData) {
        const pattern: KnowledgeBasePattern = {
          id: key,
          ...patternData,
        };

        await addPatternToKnowledgeBase(pattern);
        newPatterns.push(pattern);

        const rule = generateRule(pattern);
        await addRuleToKnowledgeBase(rule);
        newRules.push(rule);

        await updateErrorPatternsFile(pattern, rule);
      }
    }
  }

  return { patterns: newPatterns, rules: newRules };
}
